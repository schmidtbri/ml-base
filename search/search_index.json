{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the ML Base Package Documentation The ml_base package is useful for deploying machine learning models. Introduction The ml_base package defines a common set of base classes that are useful for working with machine learning model prediction code. The base classes define a set of interfaces that help to write ML code that is reusable and testable. The core of the ml_base package is the MLModel class which defines a simple interface for doing machine learning model prediction. The MLModel base class allows the developer of the model to return this information to the user of the model in a standardized way: Model Qualified Name, a unique identifier for the model Model Display Name, a friendly name for the model used in user interfaces Model Description, a description for the model Model Version, semantic version of the model codebase Model Input Schema, an object that describes the model's input data Model Output Schema, an object that describes the model's output schema The package also includes a ModelManager class that is able to instantiate and manage models that are created using the MLModel base class. FAQ Why bother with base classes and interfaces? Isn't it just extra work? Interface-driven software development can be very helpful when building complex software systems. By using the MLModel base class to deliver the prediction functionality, developing software that makes use of the machine learning model is greatly simplified, and the model is much more accessible and easier to use. Developing the prediction functionality of your ML model around the MLModel base class provides a simple \"meeting point\" between your model and anyone that wants to use it, the user doesn't need to worry about the implementation of the model and you don't need to worry about the use cases that your model will be used in. Why not just deliver a serialized model object to the software engineer? Having a class that wraps around your model object provides a great place to do things that make your model easier to use. For example: Deserialize model parameters from disk so that using the model is a easy as instantiating a class and calling predict() Validate inputs before sending them to the model Modify predictions before sending them back to the calling code Return metadata about your model Convert model inputs from a developer-friendly data structure (dictionaries and lists) to a model-friendly data structure (dataframes) Convert model outputs from a dataframe to a dictionary or list So what do I have to do to use the base classes? Create a wrapper class around your model that inherits from the MLModel base class and implement the required methods. You can follow the example implementation available in the documentation.","title":"Home"},{"location":"#welcome-to-the-ml-base-package-documentation","text":"The ml_base package is useful for deploying machine learning models.","title":"Welcome to the ML Base Package Documentation"},{"location":"#introduction","text":"The ml_base package defines a common set of base classes that are useful for working with machine learning model prediction code. The base classes define a set of interfaces that help to write ML code that is reusable and testable. The core of the ml_base package is the MLModel class which defines a simple interface for doing machine learning model prediction. The MLModel base class allows the developer of the model to return this information to the user of the model in a standardized way: Model Qualified Name, a unique identifier for the model Model Display Name, a friendly name for the model used in user interfaces Model Description, a description for the model Model Version, semantic version of the model codebase Model Input Schema, an object that describes the model's input data Model Output Schema, an object that describes the model's output schema The package also includes a ModelManager class that is able to instantiate and manage models that are created using the MLModel base class.","title":"Introduction"},{"location":"#faq","text":"","title":"FAQ"},{"location":"#why-bother-with-base-classes-and-interfaces-isnt-it-just-extra-work","text":"Interface-driven software development can be very helpful when building complex software systems. By using the MLModel base class to deliver the prediction functionality, developing software that makes use of the machine learning model is greatly simplified, and the model is much more accessible and easier to use. Developing the prediction functionality of your ML model around the MLModel base class provides a simple \"meeting point\" between your model and anyone that wants to use it, the user doesn't need to worry about the implementation of the model and you don't need to worry about the use cases that your model will be used in.","title":"Why bother with base classes and interfaces? Isn't it just extra work?"},{"location":"#why-not-just-deliver-a-serialized-model-object-to-the-software-engineer","text":"Having a class that wraps around your model object provides a great place to do things that make your model easier to use. For example: Deserialize model parameters from disk so that using the model is a easy as instantiating a class and calling predict() Validate inputs before sending them to the model Modify predictions before sending them back to the calling code Return metadata about your model Convert model inputs from a developer-friendly data structure (dictionaries and lists) to a model-friendly data structure (dataframes) Convert model outputs from a dataframe to a dictionary or list","title":"Why not just deliver a serialized model object to the software engineer?"},{"location":"#so-what-do-i-have-to-do-to-use-the-base-classes","text":"Create a wrapper class around your model that inherits from the MLModel base class and implement the required methods. You can follow the example implementation available in the documentation.","title":"So what do I have to do to use the base classes?"},{"location":"api/","text":"API documentation Base Classes Base class for building ML models that are easy to deploy and integrate. MLModel Base class for ML model prediction code. description : str property readonly Abstract property that returns a description of the model. Returns: Type Description str str: The description of the model. display_name : str property readonly Abstract property that returns a display name for the model. Returns: Type Description str str: The display name of the model. Note This is a name for the model that looks good in user interfaces. input_schema property readonly Property that returns the schema that is accepted by the predict() method. Returns: Type Description pydantic.BaseModel The input schema of the model. Note This property must return a subtype of pydantic.BaseModel. output_schema property readonly Property returns the schema that is returned by the predict() method. Returns: Type Description pydantic.BaseModel The output schema of the model. Note This property must return a subtype of pydantic.BaseModel. qualified_name : str property readonly Abstract property that returns the qualified name of the model. Returns: Type Description str str: The qualified name of the model. Warning A qualified name is an unambiguous identifier for the model. version : str property readonly Abstract property that returns the model's version as a string. Returns: Type Description str str: The version of the model. __init__ ( self ) special Create an MLModel instance by adding any deserialization and initialization code for the model. Source code in ml_base/ml_model.py @abstractmethod def __init__ ( self ): \"\"\"Create an MLModel instance by adding any deserialization and initialization code for the model.\"\"\" raise NotImplementedError () predict ( self , data ) Prediction with the model. Parameters: Name Type Description Default data data used by the model for making a prediction required Returns: Type Description object can be any python type Source code in ml_base/ml_model.py @abstractmethod def predict ( self , data ): \"\"\"Prediction with the model. Args: data: data used by the model for making a prediction Returns: object: can be any python type \"\"\" raise NotImplementedError () MLModelException Exception base class used to raise exceptions within MLModel derived classes. __init__ ( self , * args ) special Initialize MLModelException instance. Source code in ml_base/ml_model.py def __init__ ( self , * args ): \"\"\"Initialize MLModelException instance.\"\"\" Exception . __init__ ( self , * args ) MLModelSchemaValidationException Exception type used to raise schema validation exceptions within MLModel derived classes. __init__ ( self , * args ) special Initialize MLModelSchemaValidationException instance. Source code in ml_base/ml_model.py def __init__ ( self , * args ): \"\"\"Initialize MLModelSchemaValidationException instance.\"\"\" MLModelException . __init__ ( self , * args ) Utilities Singleton class that instantiates and manages model objects. __init__ ( self ) special Construct ModelManager object. Source code in ml_base/utilities/model_manager.py def __init__ ( self ): \"\"\"Construct ModelManager object.\"\"\" if self . _is_initialized is False : # pytype: disable=attribute-error self . _models = [] self . _is_initialized = True __new__ ( cls ) special staticmethod Create and return a new ModelManager instance, after instance is first created it will always be returned. Source code in ml_base/utilities/model_manager.py def __new__ ( cls ): # noqa: D102 \"\"\"Create and return a new ModelManager instance, after instance is first created it will always be returned.\"\"\" if not hasattr ( cls , \"_instance\" ): cls . _instance = super ( ModelManager , cls ) . __new__ ( cls ) cls . _instance . _is_initialized = False return cls . _instance add_model ( self , model ) Add a model to the ModelManager. Parameters: Name Type Description Default model MLModel instance of MLModel required Source code in ml_base/utilities/model_manager.py def add_model ( self , model : MLModel ) -> None : \"\"\"Add a model to the ModelManager. Args: model: instance of MLModel \"\"\" if not isinstance ( model , MLModel ): raise ValueError ( \"ModelManager instance can only hold references to objects of type MLModel.\" ) if model . qualified_name in [ model . qualified_name for model in self . _models ]: raise ValueError ( \"A model with the same qualified name is already in the ModelManager singleton.\" ) # saving the model reference to the models list self . _models . append ( model ) clear_instance () classmethod Clear singleton instance from class. Source code in ml_base/utilities/model_manager.py @classmethod def clear_instance ( cls ): \"\"\"Clear singleton instance from class.\"\"\" del cls . _instance get_model ( self , qualified_name ) Get a model object by qualified name. Parameters: Name Type Description Default qualified_name str The qualified name of the model to be returned. required Returns: Type Description MLModel Model object Exceptions: Type Description ValueError Raised if a model with the qualified name can't be found in the ModelManager singleton. Source code in ml_base/utilities/model_manager.py def get_model ( self , qualified_name : str ) -> MLModel : \"\"\"Get a model object by qualified name. Args: qualified_name: The qualified name of the model to be returned. Returns: Model object Raises: ValueError: Raised if a model with the qualified name can't be found in the ModelManager singleton. \"\"\" # searching the list of model objects to find the one with the right qualified name model_objects = [ model for model in self . _models if model . qualified_name == qualified_name ] if len ( model_objects ) == 0 : raise ValueError ( \"Instance of model ' {} ' not found in ModelManager.\" . format ( qualified_name )) else : return model_objects [ 0 ] get_model_metadata ( self , qualified_name ) Get model metadata by qualified name. Parameters: Name Type Description Default qualified_name str Qualified name of the model for which to get metadata required Returns: Type Description dict Dictionary containing information about a model in the ModelManager singleton. Note The dictionaries in the list returned by this method contain these keys: display_name qualified_name description version input_schema output_schema Source code in ml_base/utilities/model_manager.py def get_model_metadata ( self , qualified_name : str ) -> dict : \"\"\"Get model metadata by qualified name. Args: qualified_name: Qualified name of the model for which to get metadata Returns: Dictionary containing information about a model in the ModelManager singleton. !!! note The dictionaries in the list returned by this method contain these keys: - display_name - qualified_name - description - version - input_schema - output_schema \"\"\" # searching the list of model objects to find the one with the right qualified name model_objects = [ model for model in self . _models if model . qualified_name == qualified_name ] if len ( model_objects ) == 0 : raise ValueError ( \"Instance of model ' {} ' not found in ModelManager.\" . format ( qualified_name )) else : model_object = model_objects [ 0 ] return { \"display_name\" : model_object . display_name , \"qualified_name\" : model_object . qualified_name , \"description\" : model_object . description , \"version\" : model_object . version , \"input_schema\" : model_object . input_schema . schema (), \"output_schema\" : model_object . output_schema . schema () } get_models ( self ) Get a list of models in the model manager singleton. Returns: Type Description List[dict] List of dictionaries containing information about the model instances in the ModelManager singleton. Note The dictionaries in the list returned by this method contain these keys: display_name qualified_name description version Source code in ml_base/utilities/model_manager.py def get_models ( self ) -> List [ dict ]: \"\"\"Get a list of models in the model manager singleton. Returns: List of dictionaries containing information about the model instances in the ModelManager singleton. !!! note The dictionaries in the list returned by this method contain these keys: - display_name - qualified_name - description - version \"\"\" model_objects = [{ \"display_name\" : model . display_name , \"qualified_name\" : model . qualified_name , \"description\" : model . description , \"version\" : model . version } for model in self . _models ] return model_objects load_model ( self , class_path ) Import and instantiate an MLModel object from a class path. Parameters: Name Type Description Default class_path str Class path to the model's MLModel class. required Exceptions: Type Description ValueError Raised if the model is not a subtype of MLModel, or if a model with the same qualified name is already loaded in the ModelManager. Source code in ml_base/utilities/model_manager.py def load_model ( self , class_path : str ) -> None : \"\"\"Import and instantiate an MLModel object from a class path. Args: class_path: Class path to the model's MLModel class. Raises: ValueError: Raised if the model is not a subtype of MLModel, or if a model with the same qualified name is already loaded in the ModelManager. \"\"\" # splitting the class_path into module path and class name module_path = \".\" . join ( class_path . split ( \".\" )[: - 1 ]) class_name = class_path . split ( \".\" )[ - 1 ] # importing the model class model_module = importlib . import_module ( module_path ) model_class = getattr ( model_module , class_name ) # instantiating the model object from the class model_object = model_class () self . add_model ( model_object ) remove_model ( self , qualified_name ) Remove an MLModel object from the ModelManager singleton. Parameters: Name Type Description Default qualified_name str The qualified name of the model to be returned. required Exceptions: Type Description ValueError Raised if a model with the qualified name can't be found in the ModelManager singleton. Source code in ml_base/utilities/model_manager.py def remove_model ( self , qualified_name : str ) -> None : \"\"\"Remove an MLModel object from the ModelManager singleton. Args: qualified_name: The qualified name of the model to be returned. Raises: ValueError: Raised if a model with the qualified name can't be found in the ModelManager singleton. \"\"\" # searching the list of model objects to find the one with the right qualified name model_objects = [ model for model in self . _models if model . qualified_name == qualified_name ] if len ( model_objects ) == 0 : raise ValueError ( \"Instance of model ' {} ' not found in ModelManager.\" . format ( qualified_name )) else : self . _models . remove ( model_objects [ 0 ])","title":"API"},{"location":"api/#api-documentation","text":"","title":"API documentation"},{"location":"api/#base-classes","text":"","title":"Base Classes"},{"location":"api/#ml_base.ml_model","text":"Base class for building ML models that are easy to deploy and integrate.","title":"ml_base.ml_model"},{"location":"api/#ml_base.ml_model.MLModel","text":"Base class for ML model prediction code.","title":"MLModel"},{"location":"api/#ml_base.ml_model.MLModel.description","text":"Abstract property that returns a description of the model. Returns: Type Description str str: The description of the model.","title":"description"},{"location":"api/#ml_base.ml_model.MLModel.display_name","text":"Abstract property that returns a display name for the model. Returns: Type Description str str: The display name of the model. Note This is a name for the model that looks good in user interfaces.","title":"display_name"},{"location":"api/#ml_base.ml_model.MLModel.input_schema","text":"Property that returns the schema that is accepted by the predict() method. Returns: Type Description pydantic.BaseModel The input schema of the model. Note This property must return a subtype of pydantic.BaseModel.","title":"input_schema"},{"location":"api/#ml_base.ml_model.MLModel.output_schema","text":"Property returns the schema that is returned by the predict() method. Returns: Type Description pydantic.BaseModel The output schema of the model. Note This property must return a subtype of pydantic.BaseModel.","title":"output_schema"},{"location":"api/#ml_base.ml_model.MLModel.qualified_name","text":"Abstract property that returns the qualified name of the model. Returns: Type Description str str: The qualified name of the model. Warning A qualified name is an unambiguous identifier for the model.","title":"qualified_name"},{"location":"api/#ml_base.ml_model.MLModel.version","text":"Abstract property that returns the model's version as a string. Returns: Type Description str str: The version of the model.","title":"version"},{"location":"api/#ml_base.ml_model.MLModel.__init__","text":"Create an MLModel instance by adding any deserialization and initialization code for the model. Source code in ml_base/ml_model.py @abstractmethod def __init__ ( self ): \"\"\"Create an MLModel instance by adding any deserialization and initialization code for the model.\"\"\" raise NotImplementedError ()","title":"__init__()"},{"location":"api/#ml_base.ml_model.MLModel.predict","text":"Prediction with the model. Parameters: Name Type Description Default data data used by the model for making a prediction required Returns: Type Description object can be any python type Source code in ml_base/ml_model.py @abstractmethod def predict ( self , data ): \"\"\"Prediction with the model. Args: data: data used by the model for making a prediction Returns: object: can be any python type \"\"\" raise NotImplementedError ()","title":"predict()"},{"location":"api/#ml_base.ml_model.MLModelException","text":"Exception base class used to raise exceptions within MLModel derived classes.","title":"MLModelException"},{"location":"api/#ml_base.ml_model.MLModelException.__init__","text":"Initialize MLModelException instance. Source code in ml_base/ml_model.py def __init__ ( self , * args ): \"\"\"Initialize MLModelException instance.\"\"\" Exception . __init__ ( self , * args )","title":"__init__()"},{"location":"api/#ml_base.ml_model.MLModelSchemaValidationException","text":"Exception type used to raise schema validation exceptions within MLModel derived classes.","title":"MLModelSchemaValidationException"},{"location":"api/#ml_base.ml_model.MLModelSchemaValidationException.__init__","text":"Initialize MLModelSchemaValidationException instance. Source code in ml_base/ml_model.py def __init__ ( self , * args ): \"\"\"Initialize MLModelSchemaValidationException instance.\"\"\" MLModelException . __init__ ( self , * args )","title":"__init__()"},{"location":"api/#utilities","text":"","title":"Utilities"},{"location":"api/#ml_base.utilities.model_manager.ModelManager","text":"Singleton class that instantiates and manages model objects.","title":"ml_base.utilities.model_manager.ModelManager"},{"location":"api/#ml_base.utilities.model_manager.ModelManager.__init__","text":"Construct ModelManager object. Source code in ml_base/utilities/model_manager.py def __init__ ( self ): \"\"\"Construct ModelManager object.\"\"\" if self . _is_initialized is False : # pytype: disable=attribute-error self . _models = [] self . _is_initialized = True","title":"__init__()"},{"location":"api/#ml_base.utilities.model_manager.ModelManager.__new__","text":"Create and return a new ModelManager instance, after instance is first created it will always be returned. Source code in ml_base/utilities/model_manager.py def __new__ ( cls ): # noqa: D102 \"\"\"Create and return a new ModelManager instance, after instance is first created it will always be returned.\"\"\" if not hasattr ( cls , \"_instance\" ): cls . _instance = super ( ModelManager , cls ) . __new__ ( cls ) cls . _instance . _is_initialized = False return cls . _instance","title":"__new__()"},{"location":"api/#ml_base.utilities.model_manager.ModelManager.add_model","text":"Add a model to the ModelManager. Parameters: Name Type Description Default model MLModel instance of MLModel required Source code in ml_base/utilities/model_manager.py def add_model ( self , model : MLModel ) -> None : \"\"\"Add a model to the ModelManager. Args: model: instance of MLModel \"\"\" if not isinstance ( model , MLModel ): raise ValueError ( \"ModelManager instance can only hold references to objects of type MLModel.\" ) if model . qualified_name in [ model . qualified_name for model in self . _models ]: raise ValueError ( \"A model with the same qualified name is already in the ModelManager singleton.\" ) # saving the model reference to the models list self . _models . append ( model )","title":"add_model()"},{"location":"api/#ml_base.utilities.model_manager.ModelManager.clear_instance","text":"Clear singleton instance from class. Source code in ml_base/utilities/model_manager.py @classmethod def clear_instance ( cls ): \"\"\"Clear singleton instance from class.\"\"\" del cls . _instance","title":"clear_instance()"},{"location":"api/#ml_base.utilities.model_manager.ModelManager.get_model","text":"Get a model object by qualified name. Parameters: Name Type Description Default qualified_name str The qualified name of the model to be returned. required Returns: Type Description MLModel Model object Exceptions: Type Description ValueError Raised if a model with the qualified name can't be found in the ModelManager singleton. Source code in ml_base/utilities/model_manager.py def get_model ( self , qualified_name : str ) -> MLModel : \"\"\"Get a model object by qualified name. Args: qualified_name: The qualified name of the model to be returned. Returns: Model object Raises: ValueError: Raised if a model with the qualified name can't be found in the ModelManager singleton. \"\"\" # searching the list of model objects to find the one with the right qualified name model_objects = [ model for model in self . _models if model . qualified_name == qualified_name ] if len ( model_objects ) == 0 : raise ValueError ( \"Instance of model ' {} ' not found in ModelManager.\" . format ( qualified_name )) else : return model_objects [ 0 ]","title":"get_model()"},{"location":"api/#ml_base.utilities.model_manager.ModelManager.get_model_metadata","text":"Get model metadata by qualified name. Parameters: Name Type Description Default qualified_name str Qualified name of the model for which to get metadata required Returns: Type Description dict Dictionary containing information about a model in the ModelManager singleton. Note The dictionaries in the list returned by this method contain these keys: display_name qualified_name description version input_schema output_schema Source code in ml_base/utilities/model_manager.py def get_model_metadata ( self , qualified_name : str ) -> dict : \"\"\"Get model metadata by qualified name. Args: qualified_name: Qualified name of the model for which to get metadata Returns: Dictionary containing information about a model in the ModelManager singleton. !!! note The dictionaries in the list returned by this method contain these keys: - display_name - qualified_name - description - version - input_schema - output_schema \"\"\" # searching the list of model objects to find the one with the right qualified name model_objects = [ model for model in self . _models if model . qualified_name == qualified_name ] if len ( model_objects ) == 0 : raise ValueError ( \"Instance of model ' {} ' not found in ModelManager.\" . format ( qualified_name )) else : model_object = model_objects [ 0 ] return { \"display_name\" : model_object . display_name , \"qualified_name\" : model_object . qualified_name , \"description\" : model_object . description , \"version\" : model_object . version , \"input_schema\" : model_object . input_schema . schema (), \"output_schema\" : model_object . output_schema . schema () }","title":"get_model_metadata()"},{"location":"api/#ml_base.utilities.model_manager.ModelManager.get_models","text":"Get a list of models in the model manager singleton. Returns: Type Description List[dict] List of dictionaries containing information about the model instances in the ModelManager singleton. Note The dictionaries in the list returned by this method contain these keys: display_name qualified_name description version Source code in ml_base/utilities/model_manager.py def get_models ( self ) -> List [ dict ]: \"\"\"Get a list of models in the model manager singleton. Returns: List of dictionaries containing information about the model instances in the ModelManager singleton. !!! note The dictionaries in the list returned by this method contain these keys: - display_name - qualified_name - description - version \"\"\" model_objects = [{ \"display_name\" : model . display_name , \"qualified_name\" : model . qualified_name , \"description\" : model . description , \"version\" : model . version } for model in self . _models ] return model_objects","title":"get_models()"},{"location":"api/#ml_base.utilities.model_manager.ModelManager.load_model","text":"Import and instantiate an MLModel object from a class path. Parameters: Name Type Description Default class_path str Class path to the model's MLModel class. required Exceptions: Type Description ValueError Raised if the model is not a subtype of MLModel, or if a model with the same qualified name is already loaded in the ModelManager. Source code in ml_base/utilities/model_manager.py def load_model ( self , class_path : str ) -> None : \"\"\"Import and instantiate an MLModel object from a class path. Args: class_path: Class path to the model's MLModel class. Raises: ValueError: Raised if the model is not a subtype of MLModel, or if a model with the same qualified name is already loaded in the ModelManager. \"\"\" # splitting the class_path into module path and class name module_path = \".\" . join ( class_path . split ( \".\" )[: - 1 ]) class_name = class_path . split ( \".\" )[ - 1 ] # importing the model class model_module = importlib . import_module ( module_path ) model_class = getattr ( model_module , class_name ) # instantiating the model object from the class model_object = model_class () self . add_model ( model_object )","title":"load_model()"},{"location":"api/#ml_base.utilities.model_manager.ModelManager.remove_model","text":"Remove an MLModel object from the ModelManager singleton. Parameters: Name Type Description Default qualified_name str The qualified name of the model to be returned. required Exceptions: Type Description ValueError Raised if a model with the qualified name can't be found in the ModelManager singleton. Source code in ml_base/utilities/model_manager.py def remove_model ( self , qualified_name : str ) -> None : \"\"\"Remove an MLModel object from the ModelManager singleton. Args: qualified_name: The qualified name of the model to be returned. Raises: ValueError: Raised if a model with the qualified name can't be found in the ModelManager singleton. \"\"\" # searching the list of model objects to find the one with the right qualified name model_objects = [ model for model in self . _models if model . qualified_name == qualified_name ] if len ( model_objects ) == 0 : raise ValueError ( \"Instance of model ' {} ' not found in ModelManager.\" . format ( qualified_name )) else : self . _models . remove ( model_objects [ 0 ])","title":"remove_model()"},{"location":"examples/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Examples This example can be executed directly by loading the notebook file. To get started we'll install the ml_base package: !pip install ml_base Creating a Simple Model To show how to work with the MLModel base class we'll create a simple model that we can make predictions with. We'll use the scikit-learn library: !pip install scikit-learn Now we can write some code to train a model: from sklearn import datasets from sklearn import svm import pickle # loading the Iris dataset iris = datasets.load_iris() # instantiating an SVM model from scikit-learn svm_model = svm.SVC(gamma=1.0, C=1.0) # fitting the model svm_model.fit(iris.data[:-1], iris.target[:-1]) # serializing the model and saving it file = open(\"svc_model.pickle\", 'wb') pickle.dump(svm_model, file) file.close() Creating a Wrapper Class for Your Model Now that we have a model object, we'll define a class that implements the prediction functionality for the code: import os from numpy import array class IrisModel(object): def __init__(self): dir_path = os.path.abspath('') file = open(os.path.join(dir_path, \"svc_model.pickle\"), 'rb') self._svm_model = pickle.load(file) file.close() def predict(self, data: dict): X = array([data[\"sepal_length\"], data[\"sepal_width\"], data[\"petal_length\"], data[\"petal_width\"]]).reshape(1, -1) y_hat = int(self._svm_model.predict(X)[0]) targets = ['setosa', 'versicolor', 'virginica'] species = targets[y_hat] return {\"species\": species} The class above wraps the pickled model object and makes the model easier to use by converting the inputs and outputs. To use the model, all we need to do is this: model = IrisModel() prediction = model.predict(data={ \"sepal_length\":1.0, \"sepal_width\":1.1, \"petal_length\": 1.2, \"petal_width\": 1.3}) prediction {'species': 'virginica'} Creating an MLModel Class for Your Model The model is already much easier to use because it provides the prediction from a class. The user of the model doesn't need to worry about loading the pickled model object, or converting the model's input into a numpy array. However, we are still not using the MLModel abstract base class, now we'll implement a part of the MLModel's interface to show how it works: from ml_base import MLModel class IrisModel(MLModel): @property def display_name(self): return \"Iris Model\" @property def qualified_name(self): return \"iris_model\" @property def description(self): return \"A model to predict the species of a flower based on its measurements.\" @property def version(self): return \"1.0.0\" @property def input_schema(self): raise NotImplementedError() @property def output_schema(self): raise NotImplementedError() def __init__(self): dir_path = os.path.abspath('') file = open(os.path.join(dir_path, \"svc_model.pickle\"), 'rb') self._svm_model = pickle.load(file) file.close() def predict(self, data: dict): X = array([data[\"sepal_length\"], data[\"sepal_width\"], data[\"petal_length\"], data[\"petal_width\"]]).reshape(1, -1) y_hat = int(self._svm_model.predict(X)[0]) targets = ['setosa', 'versicolor', 'virginica'] species = targets[y_hat] return {\"species\": species} The MLModel base class defines a set of properties that must be provided by any class that inherits from it. Because the IrisModel class now provides this metadata about the model, we can access it directly from the model object like this: model = IrisModel() model.display_name 'Iris Model' model.version '1.0.0' As you can see, we didn't implement the schema properties above, we'll add those next. Adding Schema to Your Model To add schema information to the model class, we'll use the pydantic package: from pydantic import BaseModel, Field from pydantic import ValidationError from enum import Enum class ModelInput(BaseModel): sepal_length: float = Field(gt=5.0, lt=8.0) sepal_width: float = Field(gt=2.0, lt=6.0) petal_length: float = Field(gt=1.0, lt=6.8) petal_width: float = Field(gt=0.0, lt=3.0) class Species(str, Enum): iris_setosa = \"Iris setosa\" iris_versicolor = \"Iris versicolor\" iris_virginica = \"Iris virginica\" class ModelOutput(BaseModel): species: Species Now that we have the ModelInput and ModelOutput schemas defined as pydantic BaseModel classes, we'll add them to the IrisModel class, returning them from the input_schema and output_schema properties: from ml_base.ml_model import MLModel, MLModelSchemaValidationException class IrisModel(MLModel): @property def display_name(self): return \"Iris Model\" @property def qualified_name(self): return \"iris_model\" @property def description(self): return \"A model to predict the species of a flower based on its measurements.\" @property def version(self): return \"1.0.0\" @property def input_schema(self): return ModelInput @property def output_schema(self): return ModelOutput def __init__(self): dir_path = os.path.abspath('') file = open(os.path.join(dir_path, \"svc_model.pickle\"), 'rb') self._svm_model = pickle.load(file) file.close() def predict(self, data: dict): model_input = ModelInput(**data) X = array([model_input.sepal_length, model_input.sepal_width, model_input.petal_length, model_input.petal_width]).reshape(1, -1) y_hat = int(self._svm_model.predict(X)[0]) targets = [\"Iris setosa\", \"Iris versicolor\", \"Iris virginica\"] species = targets[y_hat] return ModelOutput(species=species) Notice that we are also using the pydantic models to validate the input before prediction and to create an object that will be returned from the model's predict() method. If we use the model class now, we'll get this result: model = IrisModel() prediction = model.predict(data={\"sepal_length\": 6.0, \"sepal_width\": 2.1, \"petal_length\": 1.2, \"petal_width\": 1.3}) prediction ModelOutput(species=<Species.iris_virginica: 'Iris virginica'>) By adding input and output schemas to the model, we can automate many other operations later. Also, we can query the model object itself for the schema: model = IrisModel() model.input_schema.schema() {'title': 'ModelInput', 'type': 'object', 'properties': {'sepal_length': {'title': 'Sepal Length', 'exclusiveMinimum': 5.0, 'exclusiveMaximum': 8.0, 'type': 'number'}, 'sepal_width': {'title': 'Sepal Width', 'exclusiveMinimum': 2.0, 'exclusiveMaximum': 6.0, 'type': 'number'}, 'petal_length': {'title': 'Petal Length', 'exclusiveMinimum': 1.0, 'exclusiveMaximum': 6.8, 'type': 'number'}, 'petal_width': {'title': 'Petal Width', 'exclusiveMinimum': 0.0, 'exclusiveMaximum': 3.0, 'type': 'number'}}, 'required': ['sepal_length', 'sepal_width', 'petal_length', 'petal_width']} model.output_schema.schema() {'title': 'ModelOutput', 'type': 'object', 'properties': {'species': {'$ref': '#/definitions/Species'}}, 'required': ['species'], 'definitions': {'Species': {'title': 'Species', 'description': 'An enumeration.', 'enum': ['Iris setosa', 'Iris versicolor', 'Iris virginica'], 'type': 'string'}}} Although it is not required to use the pydantic package to create model schemas, it is recommended. The pydantic package is installed as a dependency of the ml_base package. Using the ModelManager Class The ModelManager class is provided to help manage model objects. It is a singleton class that is designed to enable model instances to be instantiated once during the lifecycle of a process and accessed many times: from ml_base.utilities import ModelManager model_manager = ModelManager() model_manager.load_model(\"__main__.IrisModel\") The load_model() method is able to find the MLModel class that we defined above and instantiates it. The ModelManager instance can list the models being managed: model_manager.get_models() [{'display_name': 'Iris Model', 'qualified_name': 'iris_model', 'description': 'A model to predict the species of a flower based on its measurements.', 'version': '1.0.0'}] The ModelManager instance can return the metadata of one of the models: model_manager.get_model_metadata(\"iris_model\") {'display_name': 'Iris Model', 'qualified_name': 'iris_model', 'description': 'A model to predict the species of a flower based on its measurements.', 'version': '1.0.0', 'input_schema': {'title': 'ModelInput', 'type': 'object', 'properties': {'sepal_length': {'title': 'Sepal Length', 'exclusiveMinimum': 5.0, 'exclusiveMaximum': 8.0, 'type': 'number'}, 'sepal_width': {'title': 'Sepal Width', 'exclusiveMinimum': 2.0, 'exclusiveMaximum': 6.0, 'type': 'number'}, 'petal_length': {'title': 'Petal Length', 'exclusiveMinimum': 1.0, 'exclusiveMaximum': 6.8, 'type': 'number'}, 'petal_width': {'title': 'Petal Width', 'exclusiveMinimum': 0.0, 'exclusiveMaximum': 3.0, 'type': 'number'}}, 'required': ['sepal_length', 'sepal_width', 'petal_length', 'petal_width']}, 'output_schema': {'title': 'ModelOutput', 'type': 'object', 'properties': {'species': {'$ref': '#/definitions/Species'}}, 'required': ['species'], 'definitions': {'Species': {'title': 'Species', 'description': 'An enumeration.', 'enum': ['Iris setosa', 'Iris versicolor', 'Iris virginica'], 'type': 'string'}}}} The ModelManager will return a reference to a model object like this: iris_model = model_manager.get_model(\"iris_model\") iris_model.display_name 'Iris Model'","title":"Examples"},{"location":"examples/#examples","text":"This example can be executed directly by loading the notebook file. To get started we'll install the ml_base package: !pip install ml_base","title":"Examples"},{"location":"examples/#creating-a-simple-model","text":"To show how to work with the MLModel base class we'll create a simple model that we can make predictions with. We'll use the scikit-learn library: !pip install scikit-learn Now we can write some code to train a model: from sklearn import datasets from sklearn import svm import pickle # loading the Iris dataset iris = datasets.load_iris() # instantiating an SVM model from scikit-learn svm_model = svm.SVC(gamma=1.0, C=1.0) # fitting the model svm_model.fit(iris.data[:-1], iris.target[:-1]) # serializing the model and saving it file = open(\"svc_model.pickle\", 'wb') pickle.dump(svm_model, file) file.close()","title":"Creating a Simple Model"},{"location":"examples/#creating-a-wrapper-class-for-your-model","text":"Now that we have a model object, we'll define a class that implements the prediction functionality for the code: import os from numpy import array class IrisModel(object): def __init__(self): dir_path = os.path.abspath('') file = open(os.path.join(dir_path, \"svc_model.pickle\"), 'rb') self._svm_model = pickle.load(file) file.close() def predict(self, data: dict): X = array([data[\"sepal_length\"], data[\"sepal_width\"], data[\"petal_length\"], data[\"petal_width\"]]).reshape(1, -1) y_hat = int(self._svm_model.predict(X)[0]) targets = ['setosa', 'versicolor', 'virginica'] species = targets[y_hat] return {\"species\": species} The class above wraps the pickled model object and makes the model easier to use by converting the inputs and outputs. To use the model, all we need to do is this: model = IrisModel() prediction = model.predict(data={ \"sepal_length\":1.0, \"sepal_width\":1.1, \"petal_length\": 1.2, \"petal_width\": 1.3}) prediction {'species': 'virginica'}","title":"Creating a Wrapper Class for Your Model"},{"location":"examples/#creating-an-mlmodel-class-for-your-model","text":"The model is already much easier to use because it provides the prediction from a class. The user of the model doesn't need to worry about loading the pickled model object, or converting the model's input into a numpy array. However, we are still not using the MLModel abstract base class, now we'll implement a part of the MLModel's interface to show how it works: from ml_base import MLModel class IrisModel(MLModel): @property def display_name(self): return \"Iris Model\" @property def qualified_name(self): return \"iris_model\" @property def description(self): return \"A model to predict the species of a flower based on its measurements.\" @property def version(self): return \"1.0.0\" @property def input_schema(self): raise NotImplementedError() @property def output_schema(self): raise NotImplementedError() def __init__(self): dir_path = os.path.abspath('') file = open(os.path.join(dir_path, \"svc_model.pickle\"), 'rb') self._svm_model = pickle.load(file) file.close() def predict(self, data: dict): X = array([data[\"sepal_length\"], data[\"sepal_width\"], data[\"petal_length\"], data[\"petal_width\"]]).reshape(1, -1) y_hat = int(self._svm_model.predict(X)[0]) targets = ['setosa', 'versicolor', 'virginica'] species = targets[y_hat] return {\"species\": species} The MLModel base class defines a set of properties that must be provided by any class that inherits from it. Because the IrisModel class now provides this metadata about the model, we can access it directly from the model object like this: model = IrisModel() model.display_name 'Iris Model' model.version '1.0.0' As you can see, we didn't implement the schema properties above, we'll add those next.","title":"Creating an MLModel Class for Your Model"},{"location":"examples/#adding-schema-to-your-model","text":"To add schema information to the model class, we'll use the pydantic package: from pydantic import BaseModel, Field from pydantic import ValidationError from enum import Enum class ModelInput(BaseModel): sepal_length: float = Field(gt=5.0, lt=8.0) sepal_width: float = Field(gt=2.0, lt=6.0) petal_length: float = Field(gt=1.0, lt=6.8) petal_width: float = Field(gt=0.0, lt=3.0) class Species(str, Enum): iris_setosa = \"Iris setosa\" iris_versicolor = \"Iris versicolor\" iris_virginica = \"Iris virginica\" class ModelOutput(BaseModel): species: Species Now that we have the ModelInput and ModelOutput schemas defined as pydantic BaseModel classes, we'll add them to the IrisModel class, returning them from the input_schema and output_schema properties: from ml_base.ml_model import MLModel, MLModelSchemaValidationException class IrisModel(MLModel): @property def display_name(self): return \"Iris Model\" @property def qualified_name(self): return \"iris_model\" @property def description(self): return \"A model to predict the species of a flower based on its measurements.\" @property def version(self): return \"1.0.0\" @property def input_schema(self): return ModelInput @property def output_schema(self): return ModelOutput def __init__(self): dir_path = os.path.abspath('') file = open(os.path.join(dir_path, \"svc_model.pickle\"), 'rb') self._svm_model = pickle.load(file) file.close() def predict(self, data: dict): model_input = ModelInput(**data) X = array([model_input.sepal_length, model_input.sepal_width, model_input.petal_length, model_input.petal_width]).reshape(1, -1) y_hat = int(self._svm_model.predict(X)[0]) targets = [\"Iris setosa\", \"Iris versicolor\", \"Iris virginica\"] species = targets[y_hat] return ModelOutput(species=species) Notice that we are also using the pydantic models to validate the input before prediction and to create an object that will be returned from the model's predict() method. If we use the model class now, we'll get this result: model = IrisModel() prediction = model.predict(data={\"sepal_length\": 6.0, \"sepal_width\": 2.1, \"petal_length\": 1.2, \"petal_width\": 1.3}) prediction ModelOutput(species=<Species.iris_virginica: 'Iris virginica'>) By adding input and output schemas to the model, we can automate many other operations later. Also, we can query the model object itself for the schema: model = IrisModel() model.input_schema.schema() {'title': 'ModelInput', 'type': 'object', 'properties': {'sepal_length': {'title': 'Sepal Length', 'exclusiveMinimum': 5.0, 'exclusiveMaximum': 8.0, 'type': 'number'}, 'sepal_width': {'title': 'Sepal Width', 'exclusiveMinimum': 2.0, 'exclusiveMaximum': 6.0, 'type': 'number'}, 'petal_length': {'title': 'Petal Length', 'exclusiveMinimum': 1.0, 'exclusiveMaximum': 6.8, 'type': 'number'}, 'petal_width': {'title': 'Petal Width', 'exclusiveMinimum': 0.0, 'exclusiveMaximum': 3.0, 'type': 'number'}}, 'required': ['sepal_length', 'sepal_width', 'petal_length', 'petal_width']} model.output_schema.schema() {'title': 'ModelOutput', 'type': 'object', 'properties': {'species': {'$ref': '#/definitions/Species'}}, 'required': ['species'], 'definitions': {'Species': {'title': 'Species', 'description': 'An enumeration.', 'enum': ['Iris setosa', 'Iris versicolor', 'Iris virginica'], 'type': 'string'}}} Although it is not required to use the pydantic package to create model schemas, it is recommended. The pydantic package is installed as a dependency of the ml_base package.","title":"Adding Schema to Your Model"},{"location":"examples/#using-the-modelmanager-class","text":"The ModelManager class is provided to help manage model objects. It is a singleton class that is designed to enable model instances to be instantiated once during the lifecycle of a process and accessed many times: from ml_base.utilities import ModelManager model_manager = ModelManager() model_manager.load_model(\"__main__.IrisModel\") The load_model() method is able to find the MLModel class that we defined above and instantiates it. The ModelManager instance can list the models being managed: model_manager.get_models() [{'display_name': 'Iris Model', 'qualified_name': 'iris_model', 'description': 'A model to predict the species of a flower based on its measurements.', 'version': '1.0.0'}] The ModelManager instance can return the metadata of one of the models: model_manager.get_model_metadata(\"iris_model\") {'display_name': 'Iris Model', 'qualified_name': 'iris_model', 'description': 'A model to predict the species of a flower based on its measurements.', 'version': '1.0.0', 'input_schema': {'title': 'ModelInput', 'type': 'object', 'properties': {'sepal_length': {'title': 'Sepal Length', 'exclusiveMinimum': 5.0, 'exclusiveMaximum': 8.0, 'type': 'number'}, 'sepal_width': {'title': 'Sepal Width', 'exclusiveMinimum': 2.0, 'exclusiveMaximum': 6.0, 'type': 'number'}, 'petal_length': {'title': 'Petal Length', 'exclusiveMinimum': 1.0, 'exclusiveMaximum': 6.8, 'type': 'number'}, 'petal_width': {'title': 'Petal Width', 'exclusiveMinimum': 0.0, 'exclusiveMaximum': 3.0, 'type': 'number'}}, 'required': ['sepal_length', 'sepal_width', 'petal_length', 'petal_width']}, 'output_schema': {'title': 'ModelOutput', 'type': 'object', 'properties': {'species': {'$ref': '#/definitions/Species'}}, 'required': ['species'], 'definitions': {'Species': {'title': 'Species', 'description': 'An enumeration.', 'enum': ['Iris setosa', 'Iris versicolor', 'Iris virginica'], 'type': 'string'}}}} The ModelManager will return a reference to a model object like this: iris_model = model_manager.get_model(\"iris_model\") iris_model.display_name 'Iris Model'","title":"Using the ModelManager Class"}]}